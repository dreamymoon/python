                           ———————————————— week 1 ————————————————
JSON stands for JavaScript Object Notation，在这个module里有两个主要functions：dumps和loads
写代码时要先import json
json.loads() takes a string as input and produces a python object (a dictionary or a list) as output. json.dumps()相反
————
import json
def pretty(obj):
    return json.dumps(obj, sort_keys=True, indent=2)  #sort_keys=True是按照字母表排列，先数字后字母

d = {'key1': {'c': True, 'a': 90, '5': 50}, 'key2':{'b': 3, 'c': "yes"}}

print(d)
print('--------')
print(pretty(d))
————shallow-copy 与 deep-copy
import copy #引入copy模块
original = [['canines', ['dogs', 'puppies']], ['felines', ['cats', 'kittens']]]
shallow_copy_version = original[:]  # shallow-copy is original-> False;shallow-copy == original -> True
deeply_copied_version = copy.deepcopy(original)  #copy模块下的deepcopy功能
original.append("Hi there")
original[0].append(["marsupials"])
print("-------- Original -----------")
print(original)
print("-------- deep copy -----------")
print(deeply_copied_version)
print("-------- shallow copy -----------")
print(shallow_copy_version)
————以下为显示结果，可以看得deep-copy是不受original改变的影响的；
————而shallow-copy受到original部分影响：往original这个list加元素，shallow不变；往original的子list加元素，shallow跟着变化
-------- Original -----------
[['canines', ['dogs', 'puppies'], ['marsupials']], ['felines', ['cats', 'kittens']], 'Hi there']
-------- deep copy -----------
[['canines', ['dogs', 'puppies']], ['felines', ['cats', 'kittens']]]
-------- shallow copy -----------
[['canines', ['dogs', 'puppies'], ['marsupials']], ['felines', ['cats', 'kittens']]]
————
extracting from nested data要看每一层是什么类型，如果是dictionary，print .keys；如果是list，print（len（list））
第一周的课后练习Nested Data and Iteration中第四题挺难的，需要思考

                              ———————————————— week 2 ————————————————
————map function 
def triple(value):
    return 3*value

def tripleStuff(a_list):
    new_seq = map(triple, a_list)  #map(transformer,sequence)
    return list(new_seq)

things = [2, 5, 9]
things3 = tripleStuff(things)
print(things3)
————filter function
def keep_evens(nums):
    new_seq = filter(lambda num: num % 2 == 0, nums)  #filter (some filtration function ,squence)
    return list(new_seq)

print(keep_evens([3, 4, 6, 7, 0, 1]))
————List Comprehensions，集map和filter功能于一身
常用格式 [<transformer_expression> for <varname> in <sequence> if <filteration_expression>]
————zip function
L1 = [3, 4, 5]
L2 = [1, 2, 3]
L4 = list(zip(L1, L2))
print(L4)               #结果为[(3, 1), (4, 2), (5, 3)]
————L1和l2相加，如何用zip以及list comprehensions
L1 = [3, 4, 5]
L2 = [1, 2, 3]
L3 = [x1 + x2 for (x1, x2) in list(zip(L1, L2))]
print(L3)
————
